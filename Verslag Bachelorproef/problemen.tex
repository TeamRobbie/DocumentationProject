Uiteraard zijn we tijdens het project op enkele problemen gestoten. Deze problemen en eventuele oplossingen ervan worden in dit hoofdstuk besproken.

\section{Rijden aan de hand van PID-regeling}
\subsection{Positionering van de sensoren}
Een correcte PID-regeling toepassen was praktisch nogal een trial-and-error proces dat veel tijd in beslag nam. Oorspronkelijk was het de bedoeling om de stippellijn in het midden van de baan te volgen. Dit bleek echter vrij moeilijk en onbetrouwbaar om toe te passen aangezien het wagentje in de bochten de stippellijn kan kwijtraken. Daarom probeerden we ook om met de 3D-geprinte armen aan beide zijden van het wagentje een sensor bij te hangen die de zijlijn kan detecteren zodat we daarop kunnen bijsturen, maar ook dit bleek niet betrouwbaar aangezien deze sensoren in de bochten soms de middellijn oppikten waardoor het wagentje de weg helemaal kwijt raakte. Uiteindelijk beslisten we om toch bij te sturen aan de hand van de buitenste volle lijnen, we probeerden eerst om met \'e\'en sensor array voor de linkerzijlijn, en eentje voor de rechterzijlijn, ook hier waren we niet tevreden met de betrouwbaarheid van de opstelling, in sommige bochten pikte \'e\'en van deze arrays nog steeds de middellijn op waardoor het wagentje opnieuw de weg kwijt raakte. Uiteindelijk positioneerden we dus beide sensor arrays op de linkerzijlijn. Het voordeel hiervan is dat we betrouwbaarder het parcours kunnen volgen, nadelig is wel dat we ook iets trager rijden aangezien we de buitenkant van de baan volgen om de betrouwbaarheid te verzekeren.
\subsection{Bepalen van de PID-constanten}
Het bepalen van de PID-constanten $K_P$,$K_I$ en $K_D$ nam ook veel tijd in beslag aangezien we deze waarden telkens opnieuw moesten uploaden naar onze Arduino. Deze frustratie hebben we uiteindelijk opgelost eenmaal de Bluetooth-communicatie voorzien was, met enkele wijzigingen in onze Arduino-code en Python-code op de Raspberry Pi geven we deze waarde vanaf de RPi in tijdens de setup van ons wagentje. Op deze manier verliep het testen toch vlotter.

\section{Bluetooth-communicatie}
Initieel was het de bedoeling om gebruik te maken van de Adafruit Bluefruit LE SPI Friend, een low-energy Bluetooth-module. Na verschillende pogingen zonder succes met deze module om data te verzenden en ontvangen van en naar de Raspberry Pi zijn we afgestapt van deze module. We kozen als alternatief de bekendere, en beter gedocumenteerde HC05-module. Jammer genoeg verbruikt deze module wel meer vermogen, maar aangezien het vermogenverbruik niet van cruciaal belang is voor ons project is dit niet zo drastisch.

\section{RFID-lezer}
\subsection{Libraries}
Voor de communicatie tussen de Arduino en de PN532 NFC-module konden we kiezen voor drie verschillende communicatie-interfaces: HSU, I\textsuperscript{2}C en SPI.
Bij voorkeur gebruiken we voor deze communicatie SPI, het voordeel hiervan is dat dit over het algemeen veel sneller verloopt ten opzichte van I\textsuperscript{2}C-communicatie. Bij het gebruik van SPI traden er echter problemen op met het detecteren van de PN532, vermoedelijk aangezien de gedownloade bibliotheken verouderd zijn en warnings geven bij het compileren.
HSU gebruikt dan weer pinnen D0 en D1, die we tijdens het prototypen ook gebruikten om met behulp van de seri\"ele monitor te debuggen, bijgevolg konden we deze communicatie-interface ook niet gebruiken. Uiteindelijk kozen we er dus toch voor om gebruik te maken van I\textsuperscript{2}C, wat wel als voordeel heeft dat we minder pinnen hoeven te gebruiken in vergelijking met SPI.
\subsection{Duur van het inlezen}
De standaard voorbeeld-programma's die bij de libraries zaten lezen voortdurend data van RFID-tags in, aangezien we onze processor liefst nog voor andere dingen willen gebruiken was dit uiteraard niet ideaal. De beste oplossing hiervoor is werken met interrupts. Wanneer er dan een RFID-tag ingelezen wordt zal een interrupt service routine worden uitgevoerd waarin we de tag kunnen lezen en de data verzenden. Daarna wordt terug gegaan naar het hoofdprogramma. Deze methode was echter iets te omslachtig om aan de hand van deze libraries toe te passen. Daarom opteerden we voor de polling-methode, deze methode is misschien niet echt effici\"ent, maar leverde toch behoorlijke resultaten. 

\section{Arduino PCB}
Bij het ontwikkelen van de custom Arduino is er een kleine probleem bovengekomen waar we in het vervolg kunnen op letten. We voorzagen namelijk een te klein massavlak onder de ontkoppelcondensator van onze 5V-regulator. Hierdoor kan de condensator zijn warmte niet voldoende dissiperen en wordt deze zeer snel warm. Al bij al heeft dit geen echte problemen opgeleverd, maar hoe warmer de condensator, hoe korter de levensduur van de component. In het vervolg letten we dus beter op de plaatsing van zo'n componenten.